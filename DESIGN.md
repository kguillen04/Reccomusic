app.py:
The beginning of our app.py program imports programs necessary for running our website (including flask and SQL among others).

login(): Initially, the login function will clear the session, meaning the program will forget any user_id. Then, if the request method is “POST” (which occurs when the user submits the form on the “login.html” page), the function will first check to see if the user input a value for “username” and “password”. Here, to ensure that users submitted values, we implemented a check utilizing request.form.get(). If the user failed to input a value for username or password (meaning request.form.get() returned a NULL value, we set the variable “error” equal to “error: must provide username/password” and then rendered recommusic’s standard error page “apology.html” with the error variable passed into it. We then created a variable called “rows” and set it to the return of an SQL query that retrieves information of a user utilizing the username they input. Again, we implemented a check after this to ensure that the username did indeed exist within our database or that the password input by the user was the one that correlated to their username. If either of these conditions was not met, meaning their username was invalid or their password was not correct, we set the error variable equal to “error: invalid username and/or password!” and rendered the “apology.html” page with the error variable passed into it. Finally, we decided to take note of the user’s ID, which allows us to store information about their usage on the website necessary for some of the functions to work, and redirect users to the survey page once they successfully logged in. Otherwise, if the request method is “GET” the function will render the “login.html” template, which prompts the user for their username and password.

register(): Initially, the register function will clear the session, meaning the program will forget any previous user_id. Then, if the request method is “POST” (which occurs when the user submits the form on the “login.html” page), the function will first check to see if the user input a value for “username”, “password”, and “password confirmation”. Similar to login, we needed to ensure that the users submitted values and did not leave anything blank. Therefore, we utilized request.form.get() to implement a check. Essentially, if the user failed to input a value for username, password, and password confirmation, we set the variable “error” equal to “error: must provide username/password!” or “error: must confirm password!” and then rendered recommusic’s standard error page “apology.html” with the error variable passed into it. We then also checked to see if both of the passwords - password and password confirmation - matched by implementing an if condition. If they did not match, we set the variable “error” equal to “error: passwords must match!” and then rendered recommusic’s standard error page “apology.html” with the error variable passed into it. Next, we queried into the users table utilizing the inputted username to check if the username was already taken. If the username was already in use, we set the variable “error” to “error: username already taken!” and then rendered recommusic’s standard error page “apology.html” with the error variable passed into it. Next, we took the user’s password choice and hashed it utilizing the generate_password_hash() function for added security. This way if our database was breached, the users password would not be compromised as we would store it in a way that was difficult to decipher. Lastly, we utilized SQL to insert the user’s chosen username and password into our users table, took note of the user’s id (which is necessary for certain features on our website), and redirected users to the home page. Otherwise, if the request method is “GET” the function will render the “register.html” template, which prompts the user for their desired username, password, and then their password again for confirmation.

To ensure that we could store information about the users, each of the following functions requires users to be logged into their recommusic account.

survey(): If the request method is “GET”, i.e. when the user clicks a link or is redirected to the survey page, it will render the survey.html template. If the request method is “POST”, i.e. when the user submits the survey, survey() will keep track of which user is on. The function will check user input to ensure that all fields are complete, otherwise it will return an error using the apology.html template. Using request.form.get(), we gather user input values and then declare minimum and maximum values to set a range for the subsequent SQL query into the music table. Depending on the user input value for “Explicit”, we either query for both non-explicit and explicit songs, or only non-explicit songs. The SQL query returns five songs with “Danceability”, “Energy”, “Valence”, and “Explicit” values that fall in the established range. The data gathered from the database and displayed in the table includes “(Song) Name”, “Artists”, “Danceability”, “Energy”, and “Valence”. We then insert into the survey_data table the user input values for “Danceability”, “Energy”, and “Valence” and into the recommended table the “Danceability”, “Energy”, and “Valence” values of the songs for use in the data() function.

recommended(): The purpose of the recommended function is to gather information from our database about the user’s previously recommended songs and display them in an HTML page. The recommended() function first keeps track of the current user by taking note of their user_id. Then, the function executes an SQL query that selects the name and artist of the songs we had previously recommended to the user from the recommended table utilizing the user’s ID. This information is then stored in the recommended variable. Finally, it renders the “recommended.html” page with the recommended variable passed into it.

data(): The purpose of the data() function is to gather the averages of certain categories from our database about the user’s preferences and previously recommended songs, and then display them in an HTML page. The data() function first keeps track of the current user by taking note of their user_id. Then, the function executes two SQL queries. The first query selects the average values of danceability, energy, and valence from the survey_data table utilizing the user’s ID. This information is then stored in the personal_averages variable. The second query selects the average values of danceability, energy, and valence from the recommended table utilizing the user’s ID. The information from this second query is then stored in the song_averages variable. Finally, the function renders the “data.html” page with the personal_averages and song_averages variables passed into it.

about(): The “about.html” page solely contains information about the creators of recommusic as well as a button that redirects the user to a “hidden” feature of our website (an artist survey that generates song recommendations from the creator’s favorite artists). Since these features require no input from the user and do not need to access tables within our SQL database, we implemented the function to only render the “about.html” template.

playlists(): The “playlists.html” page displays embedded curated playlists for different moods and themes created by the creators. As this does not require any user input and does not need to access tables within the SQL database, we implemented the function to only render the “playlists.html” template.

artist_survey(): If the request method is “GET”, i.e. when the user clicks a link or is redirected to the survey page, it will render the survey.html template. If the request method is “POST”, i.e. when the user submits the survey, survey() will keep track of which user is on. The function will check user input to ensure that all fields are complete, otherwise it will return an error using the apology.html template. Using request.form.get(), we gather user input values and then declare minimum and maximum values to set a range for the subsequent SQL query into the music table. For the artist survey, we set a wider range for the SQL query, as the data is much more limited in scope. Depending on the user input value for “Person”, we either query taylor_data for “Angelica”, lana_data for “Emi”, or selena_data for “Kevin”. The artist whose catalog we query is designed to be a surprise for the user. Then, depending on the user input value for “Explicit”, we either query for both non-explicit and explicit songs, or only non-explicit songs. The SQL query returns one song with “Danceability”, “Energy”, “Valence”, and “Explicit” values that fall in the established range. The data gathered from the database and displayed in the table includes “Track_Name”, “Artist_Name”, “Album_Name”, “Danceability”, “Energy”, and “Valence”. We then insert into the survey_data table the user input values for “Danceability”, “Energy”, and “Valence” and into the recommended table the “Danceability”, “Energy”, and “Valence” values of the songs for use in the data() function.

music.db:
music.db serves as the primary database for recommusic.

music.db contains seven tables: users, music, survey_data, recommended, selena_data, lana_data, and taylor_data.

The users table stores an ID value (the table’s primary key), a username, and a hashed version of the user’s password. This table is specifically utilized within our program during the login and register process, which occurs in the functions login() and register() defined in app.py. With login(), we use the users table to check that the username and password they provide matches a data entry. With register(), we use the users table to make sure that the username does not already exist and to store the new username and corresponding password.

The music table was generated and created from the CSV file ‘data.csv’ from the Kaggle dataset “Spotify-Data 1921-2020”, which stores information pivotal to the primary function of our website (the music recommender) such as ‘artists’, ‘danceability’, ‘energy’, ‘name’, ‘valence’, and ‘explicit’. This table is utilized in the survey() function, where we query the table to retrieve the information of songs who have danceability, energy, valence, and explicit values that correspond to the user’s input.

The survey_data table stores the user’s ID as well as their input values for danceability, energy, and valence values. This table is used in both the survey() (or artist_survey()) and data() functions. In the survey() and artist_survey() functions, the user’s input values for danceability, energy, and valence on the survey are inserted into the table. In the data() function, we retrieve the averages of the survey_data values to relay to the user using their ID so that they have an overview of their previous responses.

The selena_data, lana_data, and taylor_data tables were generated from the CSV files ‘selena_data.csv’, ‘lana_data.csv’, and ‘taylor_data.csv’ taken from Kaggle datasets. Each of these tables stores information about a wide range of the respective artist’s songs, including ‘artist_name’, ‘track_name’, ‘danceability’, ‘energy’, ‘valence’, and ‘explicit’, which we utilize to generate recommendations for users. These three tables are utilized in the artist_survey() function where we query them to retrieve information of songs who have danceability, energy, valence, and explicit values that correspond to the user’s input in the survey.

styles.css:
In our stylesheet, we implemented our brand colors and text fonts and styles for the website background, navigation bar, tables, buttons, and general text.

html templates:
layout.html
layout is our base template for the website, from which all of recommusic’s other html templates extend. In the header, we implemented scaling to ensure that the webpage will fit most device screens. We inserted a logo and title that appears in the browser tab, and we referenced our stylesheet to connect our HTML and CSS. We imported Google Web fonts for use in said stylesheet: “Fredoka” and “Fredoka One”. We also implemented a navigation bar to direct users to the “Login” and “Register” pages if they are not logged into an account, and to the “Recommended”, “Survey”, “Data”, “Playlists”, and “About” pages if they are. Users that are logged in may also log out of their accounts using the button on the navigation bar. The layout lays the foundation for all the html templates that follow.

apology.html
apology generates an error message depending on how the error is generated. The login(), register(), survey(), and artist_survey() functions utilize the error template to check and communicate to the user what specific input is invalid.

login.html
login is where users with existing accounts can login. There are two input fields, “Username” and “Password”, which users can submit using the “Login” button for verification against the users table in the music database, assuming all tests in app.py’s login() function pass.

register.html
register is where users without existing accounts can create one. There are three input fields, “Username”, “Password”, and “Confirm Password”, which users can submit using the “Register” button to insert their new account information, assuming all tests in app.py’s register() function pass, into the users table in the music database.

survey.html
survey is where we gather user input about their mood to eventually generate song recommendations. There are four input fields, “Danceability”, “Energy”, “Valence”, and “Explicit”.
“Danceability”, “Energy”, and “Valence” have a value range of 1 - 10, integers only. “Explicit” has two possible values, “Yes” or “No”. Users can submit their input using the “Submit” button to generate songs, assuming all tests in app.py’s survey() function pass.

artist_survey.html
artist_survey is where we gather user input about their mood to eventually generate song recommendations. It follows the implementation of survey.html, however there is an additional field: “Person”. There are three possible values for “Person”: “Angelica”, “Emi”, and “Kevin”.

recommendation.html
recommendation displays the table of songs generated by the SQL query in app.py’s survey() function depending on user input from the survey. There are five columns: “Song”, “Artist”, “Danceability”, “Energy”, and “Valence”. With Jinja, we used a for loop to display the data for each song and rounded the “Danceability”, “Energy”, and “Valence” values to two decimal places.

artist_recommendation.html
artist_recommendation displays the table for a song generated by the SQL query in app.py’s artist_survey() function depending on user input from the survey. It follows the implementation of recommendation.html.

recommended.html
recommended displays a table of all song recommendations ever generated for the user through the survey() or artist_survey() functions. There are two columns: “Song Name” and “Artist”.

data.html
data displays the average “Danceability”, “Energy”, and “Valence” values from survey_data (the history of the user’s input values) and recommended (the history of song recommendations to the user) using Jinja. All values are also rounded to two decimal places.

playlists.html
playlists displays five of our curated Spotify playlists and corresponding descriptions, which we’ve embedded into the website.

about.html
about contains blurbs about our group, as well as a blurb about each group member and their music taste. We’ve embedded a curated Spotify playlist for each group member with their personal music recommendations. There is also a button that leads you to the artist_survey template.